# Chat Persistence Strategy

This document describes the implemented database-centric chat persistence architecture in CardShark. The system uses an SQLite database to provide reliable storage of all chat messages with proper state management, high performance, and data integrity.

**Status: IMPLEMENTED** - As of January 2025, the database-only chat system is fully operational.

## Background/Motivation

The previous file-based chat persistence system had several challenges:

1.  **Inconsistent File Operations**: A mixture of append operations and full file rewrites led to potential race conditions and data loss.
2.  **Error Handling Gaps**: Recovery mechanisms for corrupted files or failed operations were insufficient.
3.  **Unreliable Chat ID Tracking**: The system sometimes failed to maintain the correct state for active chats.
4.  **File Format Fragility**: The JSONL format required careful parsing and lacked built-in validation, making it prone to errors.
5.  **Inefficient State Management**: Frequent file operations, sometimes triggered by minor changes, impacted performance.

These issues necessitated a move to a more robust and structured database solution.

## SQLite Implementation Strategy

The chat persistence system uses an SQLite database, `cardshark.sqlite`, managed by [`backend/services/chat_service.py`](backend/services/chat_service.py:0). This service layer provides all database operations and is utilized by the chat API endpoints.

### Database and Schemas

*   **Database File:** `cardshark.sqlite` (located in the project root).
*   **Key Tables & Schemas:** (Refer to [`backend/schemas.py`](backend/schemas.py:0) for detailed Pydantic models and [`backend/sql_models.py`](backend/sql_models.py:0) for SQLAlchemy table definitions)
    *   **Chat Sessions Table:** Stores metadata for each chat session, primarily identified by `chat_session_uuid`. This table likely includes fields for `character_id`, `creation_timestamp`, `last_updated_timestamp`, etc.
    *   **Chat Messages Table:** Stores individual messages, linked to a chat session via `chat_session_uuid`. Each message typically includes an `id`, `role` (user/assistant), `content`, and `timestamp`.

### Core Service: `chat_service.py`

The [`backend/services/chat_service.py`](backend/services/chat_service.py:0) acts as the central hub for all chat persistence logic. Its responsibilities include:
*   Creating new chat sessions in the database.
*   Retrieving existing chat sessions and their messages.
*   Appending new messages to a chat session.
*   Saving chat session state (though this is largely managed by individual message appends and session creation/loading).
*   Handling database transactions to ensure data integrity.

### API Endpoint Interaction

The new chat API endpoints interact directly with the [`chat_service.py`](backend/services/chat_service.py:0) to perform operations:
*   `POST /api/create-new-chat`: Triggers the creation of a new chat session record in the database via the service, returning a new `chat_session_uuid`.
*   `POST /api/load-latest-chat`: Fetches the most recent chat session for a character, or a specific session if a `chat_session_uuid` is provided.
*   `POST /api/append-chat-message`: Adds a new message to the specified `chat_session_uuid` in the database.
*   `POST /api/chat/generate`: Likely involves retrieving chat history for context before generating a new message, which is then persisted.
*   `POST /api/save-chat`: While individual messages are appended, this endpoint might be used for explicit save points or metadata updates if necessary, though its role is diminished with per-message persistence.

### `chat_session_uuid` Lifecycle

The `chat_session_uuid` is central to the new system:
1.  **Creation:** A new `chat_session_uuid` is generated by the backend (typically via `uuid.uuid4()`) when a new chat is initiated through `/api/create-new-chat`.
2.  **Storage:** This UUID is stored in the chat sessions table and used as a foreign key in the chat messages table.
3.  **Client-Side Management:** The frontend client receives the `chat_session_uuid` and is responsible for storing it (e.g., in local storage) and including it in subsequent API requests for that chat session (e.g., to `/api/append-chat-message`, `/api/chat/generate`).
4.  **Retrieval:** When continuing a chat, the client sends the `chat_session_uuid` to endpoints like `/api/load-latest-chat` (or a more specific "load by UUID" endpoint if available) to retrieve the relevant history.

## Chat ID Management ( `chat_session_uuid` )

Chat identification is now managed through `chat_session_uuid` stored in the SQLite database.
*   Each new chat conversation is assigned a unique `chat_session_uuid`.
*   This UUID links all messages within that specific conversation.
*   The frontend is responsible for persisting and reusing this UUID to maintain session continuity.
*   The backend uses this UUID to fetch, update, and manage chat data in the database.

## Implementation Status

*   **Database Implementation: COMPLETED**
    *   Full SQLite schema implemented with `ChatSession` and `ChatMessage` tables
    *   Database-only services operational via `DatabaseReliableChatManager`
    *   All API endpoints updated to use database persistence
    *   File-based system completely replaced
*   **Future Database Migrations:**
    *   Database schema changes are managed through [`backend/database_migrations.py`](backend/database_migrations.py:0)
    *   SQLAlchemy models provide structured data access

## Success Criteria

The implemented SQLite-based chat persistence system has achieved:

1.  **Data Integrity:** No chat data is lost or corrupted during normal operation, API calls, or application restarts. Database transactions ensure atomicity.
2.  **Reliable Retrieval:** All chat sessions and messages are correctly loaded when requested via API, using the `chat_session_uuid`.
3.  **Persistence:** Chat history is consistently persistent across application restarts and browser sessions (managed by the frontend retaining the `chat_session_uuid`).
4.  **Performance:** The system maintains good performance, even with a large number of chat sessions and messages, leveraging database indexing.
5.  **Scalability:** The system can handle a growing number of users and chat messages efficiently.
6.  **Session Management:** Distinct chat sessions are correctly managed and isolated using `chat_session_uuid`.