from pydantic import BaseModel
from typing import Optional, List
import datetime as dt # Renamed to avoid conflict with sqlalchemy.DateTime

# Pydantic models for World
class WorldBase(BaseModel):
    name: str
    description: Optional[str] = None
    source_character_uuid: Optional[str] = None

class WorldCreate(WorldBase):
    pass

class WorldUpdate(WorldBase):
    name: Optional[str] = None # Allow partial updates

class WorldRead(WorldBase):
    world_uuid: str
    created_at: dt.datetime
    updated_at: dt.datetime

    class Config:
        orm_mode = True # Compatibility with SQLAlchemy models

# Pydantic models for Room
class RoomBase(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    introduction_text: Optional[str] = None
    grid_coordinates: Optional[str] = None
    world_uuid: str # A room must belong to a world

class RoomCreate(RoomBase):
    pass

class RoomUpdate(BaseModel): # Using BaseModel directly for more control over optional fields
    name: Optional[str] = None
    description: Optional[str] = None
    introduction_text: Optional[str] = None
    grid_coordinates: Optional[str] = None
    # world_uuid is typically not updated, or handled separately

class RoomRead(RoomBase):
    room_id: int
    # world_uuid is already in RoomBase

    class Config:
        orm_mode = True
# Pydantic models for Character (minimal for now, expand as needed)
class CharacterBase(BaseModel):
    name: str
    description: Optional[str] = None
    # Add other essential fields if needed for responses

class CharacterRead(CharacterBase):
    character_uuid: str
    png_file_path: str 
    created_at: dt.datetime
    updated_at: dt.datetime

    class Config:
        orm_mode = True

# Pydantic models for NPCInRoom (Character-Room Assignment)
class NPCInRoomBase(BaseModel):
    npc_character_uuid: str # This will likely be a path parameter in POST/DELETE
    room_id: int            # This will also likely be a path parameter
    npc_role_in_room: Optional[str] = None

class NPCInRoomCreate(BaseModel): # Request body for adding/updating NPC role in a room
    npc_role_in_room: Optional[str] = None

class NPCInRoomRead(NPCInRoomBase): # Response for a specific assignment
    id: int # The ID of the NPCsInRooms record

    class Config:
        orm_mode = True

# Response model for listing characters in a room, including their role
class CharacterInRoomResponse(CharacterRead):
    npc_role_in_room: Optional[str] = None

# Response model for listing rooms an NPC is in (RoomRead can be used directly or a more specific one if needed)
# For now, we assume existing RoomRead is sufficient.
# Pydantic models for ChatSession
class ChatSessionBase(BaseModel):
    character_uuid: str
    user_uuid: Optional[str] = None
    chat_log_path: str # Initially, this might be set by the service
    title: Optional[str] = None
    # message_count is managed by the system
    # last_message_time is managed by the system

class ChatSessionCreate(ChatSessionBase):
    # All fields from ChatSessionBase are needed for creation,
    # chat_log_path might be generated by the service upon creation.
    # start_time is server-generated.
    pass

class ChatSessionUpdate(BaseModel):
    title: Optional[str] = None
    # Potentially other updatable fields like status, if added to the model
    # last_message_time would be updated internally when a message is added
    # message_count would be updated internally

class ChatSessionRead(ChatSessionBase):
    chat_session_uuid: str
    start_time: dt.datetime
    last_message_time: Optional[dt.datetime] = None
    message_count: int

    class Config:
        orm_mode = True