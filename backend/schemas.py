from pydantic import BaseModel # Pydantic models for World
from typing import Optional, List
import datetime as dt # Renamed to avoid conflict with sqlalchemy.DateTime
class WorldBase(BaseModel):
    name: str
    description: Optional[str] = None
    source_character_uuid: Optional[str] = None

class WorldCreate(WorldBase):
    pass

class WorldUpdate(WorldBase):
    name: Optional[str] = None # Allow partial updates

class WorldRead(WorldBase):
    world_uuid: str
    created_at: dt.datetime
    updated_at: dt.datetime

    class Config:
        orm_mode = True # Compatibility with SQLAlchemy models

# Pydantic models for Room
class RoomBase(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    introduction_text: Optional[str] = None
    grid_coordinates: Optional[str] = None
    world_uuid: str # A room must belong to a world

class RoomCreate(RoomBase):
    pass

class RoomUpdate(BaseModel): # Using BaseModel directly for more control over optional fields
    name: Optional[str] = None
    description: Optional[str] = None
    introduction_text: Optional[str] = None
    grid_coordinates: Optional[str] = None
    # world_uuid is typically not updated, or handled separately

class RoomRead(RoomBase):
    room_id: int    # world_uuid is already in RoomBase

    class Config:
        orm_mode = True

# Pydantic models for Character (minimal for now, expand as needed)
class CharacterBase(BaseModel):
    name: str
    description: Optional[str] = None
    # Add other essential fields if needed for responses

class CharacterRead(CharacterBase):
    character_uuid: str
    png_file_path: str 
    created_at: dt.datetime
    updated_at: dt.datetime

    class Config:
        orm_mode = True

# Pydantic models for NPCInRoom (Character-Room Assignment)
class NPCInRoomBase(BaseModel):
    npc_character_uuid: str # This will likely be a path parameter in POST/DELETE
    room_id: int            # This will also likely be a path parameter
    npc_role_in_room: Optional[str] = None

class NPCInRoomCreate(BaseModel): # Request body for adding/updating NPC role in a room
    npc_role_in_room: Optional[str] = None

class NPCInRoomRead(NPCInRoomBase): # Response for a specific assignment    id: int # The ID of the NPCsInRooms record

    class Config:
        orm_mode = True

# Response model for listing characters in a room, including their role
class CharacterInRoomResponse(CharacterRead):
    npc_role_in_room: Optional[str] = None

# Response model for listing rooms an NPC is in (RoomRead can be used directly or a more specific one if needed)
# For now, we assume existing RoomRead is sufficient.

# Pydantic model for simple Character UUID payload
class CharacterUUIDPayload(BaseModel):
    character_uuid: str

# Pydantic models for ChatSession
class ChatSessionBase(BaseModel):
    character_uuid: str
    user_uuid: Optional[str] = None
    chat_log_path: Optional[str] = None # Can be service-generated if not provided
    title: Optional[str] = None
    # message_count is managed by the system
    # last_message_time is managed by the system

class ChatSessionCreate(ChatSessionBase):
    # All fields from ChatSessionBase are needed for creation,
    # chat_log_path might be generated by the service upon creation.
    # start_time is server-generated.
    pass

class ChatSessionUpdate(BaseModel):
    title: Optional[str] = None
    chat_log_path: Optional[str] = None  # Added for consistency if path is updated
    chat_log: Optional[List[dict]] = None # Added to allow updating the log content
    message_count: Optional[int] = None # Allow updating message count
    # Potentially other updatable fields like status, if added to the model
    # last_message_time would be updated internally when a message is added

# Schema for saving chat content
class ChatSavePayload(BaseModel):
    chat_session_uuid: str
    messages: List[dict]
    title: Optional[str] = None

class ChatMessageAppend(BaseModel):
    chat_session_uuid: str
    message: dict # Represents a single message object, e.g., {"user": "hello", "assistant": "hi"} or {"sender": "user", "text": "Hello"}

class ChatGenerateRequest(BaseModel):
    chat_session_uuid: str
    # `current_context` could be the list of messages so far, or a pre-processed string.
    # Using List[dict] to represent a list of message objects.
    current_context: List[dict]
    # Potentially add other parameters like max_tokens, temperature for generation

class ChatGenerateResponse(BaseModel):
    chat_session_uuid: str
    generated_message: dict # The new message from the assistant
    # Potentially include updated context or other relevant data

class ChatSessionRead(ChatSessionBase):
    chat_session_uuid: str
    start_time: dt.datetime
    last_message_time: Optional[dt.datetime] = None
    message_count: int
    export_format_version: Optional[str] = None
    is_archived: Optional[bool] = False
    messages: Optional[List[dict]] = None
    success: Optional[bool] = None

    class Config:
        orm_mode = True

# Pydantic models for ChatMessage (Phase 1 database transition)
class ChatMessageBase(BaseModel):
    role: str  # user/assistant/system
    content: str
    status: Optional[str] = "complete"  # complete/generating/error
    reasoning_content: Optional[str] = None
    metadata_json: Optional[dict] = None

class ChatMessageCreate(ChatMessageBase):
    chat_session_uuid: str

class ChatMessageUpdate(BaseModel):
    content: Optional[str] = None
    status: Optional[str] = None
    reasoning_content: Optional[str] = None
    metadata_json: Optional[dict] = None

class ChatMessageRead(ChatMessageBase):
    id: str # Frontend expects 'id'
    message_id: str
    chat_session_uuid: str
    timestamp: dt.datetime
    created_at: dt.datetime
    updated_at: dt.datetime

    class Config:
        orm_mode = True

# Enhanced ChatSession schemas for database transition
class ChatSessionCreateV2(BaseModel):
    """Updated ChatSession creation schema for database-first approach."""
    character_uuid: str
    user_uuid: Optional[str] = None
    title: Optional[str] = None
    export_format_version: Optional[str] = None
    is_archived: Optional[bool] = False
    chat_type: Optional[str] = 'chat'  # 'chat' or 'workshop'

class ChatSessionUpdateV2(BaseModel):
    """Updated ChatSession update schema for database-first approach."""
    title: Optional[str] = None
    export_format_version: Optional[str] = None
    is_archived: Optional[bool] = None
    message_count: Optional[int] = None

class ChatSessionReadV2(BaseModel):
    """Updated ChatSession read schema with database messages."""
    chat_session_uuid: str
    character_uuid: str
    user_uuid: Optional[str] = None
    start_time: dt.datetime
    last_message_time: Optional[dt.datetime] = None
    message_count: int
    title: Optional[str] = None
    export_format_version: Optional[str] = None
    is_archived: bool
    chat_type: Optional[str] = 'chat'  # 'chat' or 'workshop'
    messages: Optional[List[ChatMessageRead]] = None

    class Config:
        orm_mode = True